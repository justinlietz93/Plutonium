"""
Vulnerability checker module.

This module provides functionality to fetch vulnerability data for dependencies
using external vulnerability databases like the VulnCheck API via PURLs.
"""

import requests
import logging
import time
from typing import List, Optional, Dict, Any
from threading import Lock
import urllib.parse # Needed for PURL construction
import json # For parsing JSON

# Use relative imports within the package
from .constants import DEFAULT_TIMEOUT, API_URLS # Assumes VulnCheck_PURL is defined


class VulnerabilityChecker:
    """Class to fetch vulnerability data for dependencies using VulnCheck PURL API."""

    RATE_LIMIT_REQUESTS = 40
    RATE_LIMIT_SECONDS = 30

    def __init__(self, vulncheck_token: Optional[str] = None):
        """
        Initialize the vulnerability checker with the VulnCheck API token.

        Args:
            vulncheck_token: Optional VulnCheck API token.
        """
        self.logger = logging.getLogger("vulnerability_checker")
        self.token = vulncheck_token
        self.headers = None
        self.skip_reason: Optional[str] = None # Store the reason why checks are skipped

        if self.token:
            self.headers = {
                'Accept': 'application/json',
                'Authorization': f'Bearer {self.token}'
            }
            self.logger.info("Initialized VulnerabilityChecker with VulnCheck API token.")
        else:
            self.logger.warning("Initialized VulnerabilityChecker without VulnCheck API token. Vulnerability checks will be skipped.")
            # Set skip reason immediately if no token provided
            self.skip_reason = "Token Missing"

        # Rate limiting state
        self.request_timestamps: List[float] = []
        self.lock = Lock()

    # _enforce_rate_limit method remains the same as before...
    def _enforce_rate_limit(self):
        """Enforce a simplified rate limit."""
        if not self.token:
             return # No rate limit enforcement without a token

        with self.lock:
            current_time = time.time()
            self.request_timestamps = [t for t in self.request_timestamps if current_time - t < self.RATE_LIMIT_SECONDS]
            if len(self.request_timestamps) >= self.RATE_LIMIT_REQUESTS:
                wait_until = self.request_timestamps[0] + self.RATE_LIMIT_SECONDS
                sleep_time = (wait_until - current_time) + 0.05
                if sleep_time > 0:
                    self.logger.debug(f"Rate limit possibly reached ({len(self.request_timestamps)} req), sleeping for {sleep_time:.2f} seconds")
                    time.sleep(sleep_time)
                current_time = time.time()
                self.request_timestamps = [t for t in self.request_timestamps if current_time - t < self.RATE_LIMIT_SECONDS]
            self.request_timestamps.append(current_time)

    # _construct_purl method remains the same as before...
    def _construct_purl(self, package_name: str, version: str, environment: str) -> Optional[str]:
        """Construct PURL based on environment."""
        purl_version = version.lstrip('v') # Remove leading 'v' if present

        if environment == "Python":
            return f"pkg:pypi/{package_name}@{purl_version}"
        elif environment == "Node.js":
            purl_package_name = package_name
            if package_name.startswith('@'):
                try:
                    scope, name = package_name.split('/', 1)
                    purl_package_name = f"{urllib.parse.quote(scope)}/{name}"
                except ValueError:
                    self.logger.error(f"Could not parse scoped NPM package name: {package_name}")
                    return None
            return f"pkg:npm/{purl_package_name}@{purl_version}"
        elif environment == "Maven":
            try:
                group_id, artifact_id = package_name.split(':')
                return f"pkg:maven/{group_id}/{artifact_id}@{purl_version}"
            except ValueError:
                 self.logger.error(f"Could not parse Maven identifier: {package_name}. Expected 'groupId:artifactId'.")
                 return None
        elif environment == "Ruby":
             return f"pkg:gem/{package_name}@{purl_version}"
        elif environment == "Go":
             encoded_module_path = urllib.parse.quote(package_name)
             return f"pkg:golang/{encoded_module_path}@{purl_version}"
        else:
            self.logger.warning(f"PURL construction not implemented for environment: {environment}")
            return None


    # In core/vulnerability_checker.py

    # __init__, _enforce_rate_limit, _construct_purl methods remain the same as the last version...

    def fetch_vulnerabilities(self, package_name: str, version: str, environment: str) -> List[str]:
        """
        Fetch vulnerabilities - CURRENTLY DISABLED for VulnCheck PURL endpoint.
        Sets skip reason and returns N/A.

        Args:
            package_name: The name/identifier of the package.
            version: The specific version of the package.
            environment: The environment (e.g., "Node.js", "Python").

        Returns:
            Always returns ["N/A (Skipped)"] in this disabled state.
        """
        # --- Check for existing reasons to skip (like missing token) ---
        if self.skip_reason:
            self.logger.debug(f"Skipping vulnerability check for {package_name}@{version}: Reason='{self.skip_reason}'")
            return ["N/A (Skipped)"]
        # This check might be redundant if __init__ sets skip_reason correctly, but safe to keep
        if not self.token:
             self.logger.warning(f"Skipping vulnerability check for {package_name}@{version}: Token Missing")
             if not self.skip_reason: self.skip_reason = "Token Missing"
             return ["N/A (Skipped)"]
        # --- End Skip Check ---

        # --- Explicitly Skip PURL Check ---
        # Reason: The /v3/purl endpoint returned a 402 Payment Required error,
        # indicating it requires a paid plan. Disabling this check.
        skip_msg = "VulnCheck PURL API Requires Paid Plan / Check Disabled"
        self.logger.debug(f"Skipping VulnCheck PURL check for {package_name}@{version} ({skip_msg}).")
        if not self.skip_reason: # Set the skip reason if not already set (e.g., by missing token)
            self.skip_reason = skip_msg
        return ["N/A (Skipped)"]

        # --- COMMENTED OUT: Original PURL API Call Logic ---
        # purl = self._construct_purl(package_name, version, environment)
        # if not purl:
        #      return ["Error (Bad PURL)"]
        #
        # url = API_URLS.get("vulncheck_purl")
        # if not url:
        #     self.logger.error("VulnCheck PURL API URL not found in constants.")
        #     return ["Error (Config)"]
        #
        # params = {'purl': purl}
        # self.logger.debug(f"Fetching vulnerabilities for PURL: {purl}")
        # self._enforce_rate_limit()
        # try:
        #     response = requests.get(url, headers=self.headers, params=params, timeout=DEFAULT_TIMEOUT)
        #     # ... (Original response handling for 401, 403, 404, 429, 200 OK) ...
        #     # ... (Original JSON parsing logic) ...
        # except requests.exceptions.RequestException as e:
        #     # ... (Original error handling) ...
        # --- END COMMENTED OUT ---


        # --- START: Comments on using Free NVD++ Indices (Alternative Implementation) ---
        """
        ALTERNATIVE IMPLEMENTATION NOTES (Using Free VulnCheck NVD++ Indices):

        If you want to use the free NVD++ indices (`nist-nvd2` or `nist-nvd`)
        provided by VulnCheck Community access, you would need to:

        1. Generate a reliable CPE string:
           - This is the hardest part. You need to map the package_name and version
             (and potentially vendor info) to the standard CPE format:
             `cpe:2.3:a:vendor:product:version:*:*:*:*:*:*:*`
           - Example (might be inaccurate):
             # vendor = package_name.split(':')[0] if environment == "Maven" else package_name.split('/')[0] # Very rough guess
             # product = package_name.split(':')[-1] if environment == "Maven" else package_name.split('/')[-1]
             # cpe_string = f"cpe:2.3:a:{vendor}:{product}:{version}:*:*:*:*:*:*:*"
             # self.logger.debug(f"Constructed CPE (needs validation): {cpe_string}")

        2. Choose the correct endpoint and query parameter:
           - You might use the VulnCheck `/v3/cpe` endpoint if it's available for free
             (check API Sandbox/Docs) OR the `/v3/index/{index_name}` endpoint.
           - For `/v3/index/nist-nvd2`: You'd likely need to use query parameters
             to filter the index data by CPE string. Check VulnCheck docs for how
             to query indices. Example *guess*:
             # index_url = "https://api.vulncheck.com/v3/index/nist-nvd2"
             # index_params = {'cpeName': cpe_string, 'limit': 10} # Example params

        3. Make the API Request:
           - Use `self.headers` (which includes your token, needed even for free indices).
           - Call `requests.get(index_url, headers=self.headers, params=index_params, ...)`

        4. Parse the Response:
           - The response structure from `/v3/index/...` or `/v3/cpe` will be
             different from `/v3/purl`. You'll need to inspect the response
             (using API Sandbox or a test call) and adapt the JSON parsing logic
             to extract the relevant vulnerability IDs (e.g., CVEs).

        5. Handle Errors: Include robust error handling for network issues, timeouts,
           API errors (4xx/5xx), and parsing problems specific to the chosen endpoint.

        Due to the complexity of CPE generation and adapting to the index API,
        this alternative requires significant development effort.
        """
        # --- END: Comments on using Free NVD++ Indices ---